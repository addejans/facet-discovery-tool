* The Projector (Fourier-Motzkin)
  :PROPERTIES:
  :ID:       68f91b13-7003-4091-b3b0-55315e9d516c
  :END:

** Preamble
   :PROPERTIES:
   :ID:       2456ed95-e292-4dcd-9c55-8104f2047047
   :END:
#+BEGIN_SRC lisp :tangle "projector.lisp"
(in-package #:facet-discovery-tool)
#+END_SRC

* General structure
   :PROPERTIES:
   :ID:       b929f0e7-13d9-48df-bfe7-6d3a5233927a
   :END:
The parameters are ~c~, the matrix of equalities and inequalities,
~ne~ the number of equalities (which are all at the beginning) and
~nv~ the number of variables onto which to project (and they are at
positions 1 to ~nv~ since column 0 has the constant side.)

First, use all ~ne~ equalities to eliminate ~ne~ variables (starting
from the right).  Decide which variable to eliminate next. (In time we
can think to optimize the choice.)

Sort the matrix on the coefficient of that variable. For every pair of
one negative and one positive coefficient, generate the new
inequality. (This we will do in parallel, eventually.)

Then get rid of redundancy. (Eventually.)

Rinse and repeat until only ~nv~ variables are left. (Every
coefficient past ~nv~ is zero.)

There must be a final redundancy elimination, which must be
perfect. And also a reduction to "smallest" integer
coefficient. (Maybe take out the gcd from every row).


*** DONE Reduce equations

Eliminate variables from the system using the ~ne~ equations.

This function assumes the user is not an idiot.  We need to fix this
eventually.
#+BEGIN_SRC lisp :tangle "projector.lisp"
  (defun first-non-zero (row nv)
    "First non-zero position past nv."
    (do ((i (1+ nv) (1+ i)))
        ((not (zerop (aref row i))) i)))
#+END_SRC

#+RESULTS:
: FIRST-NON-ZERO

#+BEGIN_SRC lisp
(equalp 7 (first-non-zero #(1 0 0 0 0 0 0 2 0 2 4) 6))
#+END_SRC

#+RESULTS:
: NIL
A row operation that zeros out the destination at pos from the source at pos.  
#+BEGIN_SRC lisp :tangle "projector.lisp"
  (defun zero-out (dest source pos)
    "In-place, update the destination if coefficient at pos is non-zero."
    (when (not (zerop (aref dest pos)))
      (let* ((a (aref source pos))
             (b (aref dest pos))
             (c (/ (- b) a)))
        (kaplusb c source dest))))
#+END_SRC

#+RESULTS:
: ZERO-OUT

#+BEGIN_SRC lisp
(equalp #(11 1 4 0) (zero-out #(6 0 2 1) #(5 1 2 -1) 3))
#+END_SRC

#+RESULTS:
: T

A blas-type operator: k times 'row a' add to 'row b'.  
#+BEGIN_SRC lisp :tangle "projector.lisp"
  (defun kaplusb (k a b)
    (dotimes (i (length a) b)
      (incf (aref b i) (* k (aref a i)))))
#+END_SRC

#+RESULTS:
: KAPLUSB

#+BEGIN_SRC lisp
(equalp #(2 4 7) (let ((dest #(0 0 1))) (kaplusb 2 #(1 2 3) dest) dest))
#+END_SRC

#+RESULTS:
: NIL

Consider the first ~ne~ rows.  For each one, find the first non-zero
coefficient in the 'additional' variables (not among the variables
that we need to project on). It is assumed that there is such a
non-zero coefficient. (What should we do if not?) Isolate that
variable and substitute its expression into all subsequent rows.

For instance given a row $1 = x_1 + y_1 + y2$, we isolate $y1 =
1-x_1-y_2$ and substitute that into all other equations and
inequalities.
#+BEGIN_SRC lisp :tangle "projector.lisp"
  (defun eliminate-equations (C ne nv)
    (do ((i 0 (1+ i))
         (row (car C) (car (cdr C)))
         (C C (cdr C)))
        ((= i ne) C)
      (let ((pos (first-non-zero row nv)))
        (normalize-row row pos)
        (dolist (other-row (cdr C))
          (zero-out other-row row pos)))))
#+END_SRC

#+RESULTS:
: ELIMINATE-EQUATIONS

#+BEGIN_SRC lisp
(equalp '(#(0 4 2 0 5)) (let ((C '(#(0 1 0 -1 0) #(0 1 2 3 5))))
    (eliminate-equations C 1 2)))
#+END_SRC

#+RESULTS:
: T

#+BEGIN_SRC lisp :results output
  (let ((param '(1 2 2 2))
        (generator #'gen-at-least))
    (multiple-value-bind (C ne nv) (apply generator param)
      (output-matrix C ne nv)
      (format t "~&NEW~&")
      (output-matrix (eliminate-equations C ne nv) 0 nv)))
#+END_SRC

#+RESULTS:
#+begin_example
   0  =  -1x( 1)                    +1y( 4)  +2y( 5)                           
   1  =                    +1y( 3)  +1y( 4)  +1y( 5)                           
   0  =           -1x( 2)                                      +1y( 7)  +2y( 8)
   1  =                                               +1y( 6)  +1y( 7)  +1y( 8)
   1 <=                                      +1y( 5)                    +1y( 8)
   0 <=                    +1y( 3)                                             
  -1 <=                    -1y( 3)                                             
   0 <=                             +1y( 4)                                    
  -1 <=                             -1y( 4)                                    
   0 <=                                      +1y( 5)                           
  -1 <=                                      -1y( 5)                           
   0 <=                                               +1y( 6)                  
  -1 <=                                               -1y( 6)                  
   0 <=                                                        +1y( 7)         
  -1 <=                                                        -1y( 7)         
   0 <=                                                                 +1y( 8)
  -1 <=                                                                 -1y( 8)
NEW
   1 <=                                      +1y( 5)                    +1y( 8)
  -1 <=  -1x( 1)                             +1y( 5)                           
   0 <=  +1x( 1)                             -1y( 5)                           
   0 <=  +1x( 1)                             -2y( 5)                           
  -1 <=  -1x( 1)                             +2y( 5)                           
   0 <=                                      +1y( 5)                           
  -1 <=                                      -1y( 5)                           
  -1 <=           -1x( 2)                                               +1y( 8)
   0 <=           +1x( 2)                                               -1y( 8)
   0 <=           +1x( 2)                                               -2y( 8)
  -1 <=           -1x( 2)                                               +2y( 8)
   0 <=                                                                 +1y( 8)
  -1 <=                                                                 -1y( 8)
#+end_example

#+COMMENT
|  0 | -1 |  0 |  0 |  1 |  2 |  0 |  0 |  0 |
|  1 |  0 |  0 |  1 |  1 |  1 |  0 |  0 |  0 |
|  0 |  0 | -1 |  0 |  0 |  0 |  0 |  1 |  2 |
|  1 |  0 |  0 |  0 |  0 |  0 |  1 |  1 |  1 |
|  1 |  0 |  0 |  0 |  0 |  1 |  0 |  0 |  1 |
|  0 |  0 |  0 |  1 |  0 |  0 |  0 |  0 |  0 |
| -1 |  0 |  0 | -1 |  0 |  0 |  0 |  0 |  0 |
|  0 |  0 |  0 |  0 |  1 |  0 |  0 |  0 |  0 |
| -1 |  0 |  0 |  0 | -1 |  0 |  0 |  0 |  0 |
|  0 |  0 |  0 |  0 |  0 |  1 |  0 |  0 |  0 |
| -1 |  0 |  0 |  0 |  0 | -1 |  0 |  0 |  0 |
|  0 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |  0 |
| -1 |  0 |  0 |  0 |  0 |  0 | -1 |  0 |  0 |
|  0 |  0 |  0 |  0 |  0 |  0 |  0 |  1 |  0 |
| -1 |  0 |  0 |  0 |  0 |  0 |  0 | -1 |  0 |
|  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  1 |
| -1 |  0 |  0 |  0 |  0 |  0 |  0 |  0 | -1 |



*** DONE Normalize

Consider $x_i$ to be the variable currently being eliminated.  Divide
every inequality where the coefficient of $x_i$ is nonzero by that
coefficient.  The end result of this step should leave every
inequality such that the new coefficient on $x_i$ is one of three
options: 1, -1, or zero.

(This process can definitely be its own function but its efficiency
may need to be considered.)

#+BEGIN_SRC lisp :tangle "projector.lisp"
(defun divide-row (row divisor)
    (loop for i from 0 below (length row)
             do (setf (aref row i) (/ (aref row i) divisor)))) ; ditch this double aref!

(defun normalize-row (row pos)
    (let ((a (abs (aref row pos))))
     (when (not (zerop a))
         (divide-row row a)))
row) 

(defun normalize (C pos)
    (map 'list (lambda (x) (normalize-row x pos)) C))


#+END_SRC

#+RESULTS:
: NORMALIZE

#+BEGIN_SRC lisp
(equalp (let ((C '( #(0 1 5 2) #(0 1 -4 3)))) (normalize  C 2)) '(#(0 1/5 1 2/5)
#(0 1/4 -1 3/4)))
#+END_SRC

#+RESULTS:
: T

*** DONE Partition and Compare

**** DONE Partition

Ignore henceforth inequalities containing a coefficient of zero on
$x_i$.  Construct two sets, ~Pos~ and ~Neg~, such that every
inequality belongs to one or the other depending on the sign of the
coefficient on $x_i$. The parameter ~xi~ is the address of the
coefficient on $x_i$ in ~C~ and probably needs to be renamed for
better readability.

#+BEGIN_SRC lisp :tangle "projector.lisp"
  (defun partition (C xi)
    (normalize C xi)
    (let ((pos)
          (neg)
          (naught))
      (dolist (row C (values (nreverse pos) (nreverse neg) (nreverse naught)))
        (cond ((minusp (aref row xi)) (push row neg))
              ((plusp (aref row xi)) (push row pos))
              (t (push row naught))))))
#+END_SRC

#+RESULTS:
: PARTITION

#+BEGIN_SRC lisp
(equalp (partition '( #(1 2 3 4) #(1 2 -3 4) #(1 2 0 4)) 2)
(values '( #(1/3 2/3 1 4/3) ) '( #(1/3 2/3 -1 4/3)) '( #(1 2 0 4))))

#+END_SRC

#+RESULTS:
: T


**** DONE Zeroing out the variable being eliminated

For every pair of inequalities $p_i$ and $n_i$, where $p_i \in$ ~Pos~
and $n_i \in$ ~Neg~, take the sum (row addition in the matrix). Append
the resulting inequality to the matrix.

I am thinking that we could do the redundency elimination separately
on the sets pos neg and naught.  Because there is no way an inequality
in one set is a multiple of one in another set.
#+BEGIN_SRC lisp :tangle "projector.lisp"
  (defun eliminate (C xi)
      (multiple-value-bind (pos neg naught) (partition C xi)
        (dolist (p pos naught)
          (dolist (n neg)
            (push (map 'vector #'+ p n) naught)))))
#+END_SRC

#+RESULTS:
: ELIMINATE

#+BEGIN_SRC lisp :results output
  (let ((C '(#(0 1 5 2) #(0 1 0 5) #(0 1 -4 -1))))
    (multiple-value-bind (P N Z) (partition C 2)
      (format t "~&+:~a~&-:~a~&z:~a" P N Z)
      ))
#+END_SRC

#+RESULTS:
: +:(#(0 1/5 1 2/5))
: -:(#(0 1/4 -1 -1/4))
: z:(#(0 1 0 5))

#+BEGIN_SRC lisp :results output
  (let ((C '(#(0 1 -5 2) #(6 1 1 5) #(0 1 0 5) #(0 1 -4 -1) #(1 1 2 3))))
      (format t "~&~a" (eliminate C 2))
      )
#+END_SRC

#+RESULTS:
: (#(1/2 3/4 0 5/4) #(1/2 7/10 0 19/10) #(6 5/4 0 19/4) #(6 6/5 0 27/5)
:  #(0 1 0 5))

**** DONE Removal

Delete every row from the matrix who belonged to ~Pos~ or ~Neg~.  The
only rows not used at this point (and thus, the rows that must remain)
are those that had a coefficient of zero on $x_i$ to begin with. So,
the new matrix will be the union of the following: rows from the
original with the mentioned zero coefficient, and the result of
~compare~.

At the end of each comparison and removal, the matrix present
represents a set of equalities and inequalities with $x_i$ eliminated.

#+BEGIN_SRC lisp
(defun removal (C xi) ; DEPRECATED; post-compare garbage collection ought to handle this
    (if C
        (if (zerop (aref (car C) xi))
            (cons (car C) (removal (cdr C) xi)) ; keep it, continue to the rest
            (removal (cdr C) xi)) ; toss it, continue to the rest
        nil))
#+END_SRC

#+RESULTS:
: REMOVAL

And finally, the whole elimination step for one variable: (thought:
how can we best keep track of number of equations in C? discuss
monday)



*** Experiment
#+BEGIN_SRC lisp :tangle "projector.lisp"
(defun vars-to-elim (C nv) ; returns a sequence of the positions of variables 
                           ; to be eliminated, currently right to left
        (reverse (number-sequence (+ nv 1) (- (length (car C)) 1))))

#+END_SRC

#+RESULTS:
: VARS-TO-ELIM

#+BEGIN_SRC lisp :tangle "projector.lisp"
  (defun eliminate-all (C nv &optional (i (1- (length (car C)))))
    (if (= i nv)
        C
        (eliminate-all (eliminate C i) nv (1- i))))
#+END_SRC

#+RESULTS:
: ELIMINATE-ALL

#+BEGIN_SRC lisp
  (let ((C '( #(0 1 5 4 2) #(0 1 -4 -3 -3))))
    (eliminate C 4))
#+END_SRC

#+RESULTS:
| 0 | 5/6 | 7/6 | 1 | 0 |

#+BEGIN_SRC lisp :tangle "projector.lisp"
(defun redundancy-trim (C)
    (remove-duplicates C :test #'row-multiple-p))

#+END_SRC

#+RESULTS:
: REDUNDANCY-TRIM

#+BEGIN_SRC lisp :tangle "projector.lisp"
(defun gcd-row (row) ; thank Euclid for the GCD being associative
    (let ((rowlist (loop for x across row collect x)))
         (reduce (lambda (x y) (gcd x y)) rowlist)))

#+END_SRC

#+RESULTS:
: GCD-ROW

#+BEGIN_SRC lisp
(equalp (gcd-row #(2 4 10 6)) 2)

#+END_SRC

#+RESULTS:
: T

#+BEGIN_SRC lisp :tangle "projector.lisp"
(defun divide-by-gcd (row)
         (progn (divide-row row (gcd-row row)) ; row your boat
                row))

(defun coeff-reduction (C)
    (if C
        (cons (divide-by-gcd (car C)) (coeff-reduction (cdr C)))
        C))

#+END_SRC

#+RESULTS:
: COEFF-REDUCTION

#+BEGIN_SRC lisp
(equalp (coeff-reduction '( #(1 2 3 4) #(2 4 6 8) #(3 6 9 12)))
'(#(1 2 3 4) #(1 2 3 4) #(1 2 3 4)))

#+END_SRC

#+RESULTS:
: T

#+BEGIN_SRC lisp
(equalp #(1 3 2 10) (let ((row (divide-by-gcd #(3 9 6 30)))) row))

#+END_SRC

#+RESULTS:
: T

#+BEGIN_SRC lisp :tangle "projector.lisp"
(defun trivial-row-p (row)
  (reduce (lambda (x y) (and x y)) (map 'vector #'zerop row) :start 1))

#+END_SRC

#+RESULTS:
: TRIVIAL-ROW-P

#+BEGIN_SRC lisp
(and (trivial-row-p #(-1 0 0 0 0))
 (trivial-row-p #(-2 0 0 0 0)))

#+END_SRC

#+RESULTS:
: T

#+BEGIN_SRC lisp :tangle "projector.lisp"
(defun redun-trivial (C)
  (cond ((null C) nil)
        ((trivial-row-p (car C)) (redun-trivial (cdr C)))
        (T (cons (car C) (redun-trivial (cdr C))))))

#+END_SRC

#+RESULTS:
: REDUN-TRIVIAL

#+BEGIN_SRC lisp
(equalp (redun-trivial '(#(0 1 2 3 4) #(-1 0 0 0 0) #(0 0 0 0 0) #(1 1 1 1 1)))
    '(#(0 1 2 3 4) #(1 1 1 1 1)))

#+END_SRC

#+RESULTS:
: T
For now, we are doing this just to check.  The logic should be that we do this after every variable elimination and we do not go past the last column eliminated.  
#+BEGIN_SRC lisp :tangle "projector.lisp"
  (defun row-multiple-p (row1 row2)
    "True iff one is a multiple of the other."
    (let ((ratio))
      (do*  ((i 0 (1+ i))
             (a (aref row1 i) (aref row1 i))
             (b (aref row2 i) (aref row2 i)))
            ((= (1- (length row1)) i) t)
        (cond ((and (zerop a) (not (zerop b))) (return nil))
              ((and (zerop b) (not (zerop a))) (return nil))
              ((and (zerop a) (zerop b)))
              ((null ratio) (setq ratio (/ a b)))
              ((not (= ratio (/ a b))) (return nil))))))
#+END_SRC

#+RESULTS:
: ROW-MULTIPLE-P

#+BEGIN_SRC lisp
(row-multiple-p #(1 0 4 0) #(2 0 8 0) 3)
#+END_SRC

#+RESULTS:
: T

#+BEGIN_SRC lisp
(row-multiple-p #(1 0 3 4) #(2 4 6 8))

#+END_SRC

#+RESULTS:
: NIL

#+BEGIN_SRC lisp :tangle "projector.lisp"
(defun has-multiple-p (C)
  (if (and C (cdr C))
      (let ((row1 (car C)))
        (reduce (lambda (x y) (or x y)) 
          (mapcar (lambda (r) (row-multiple-p r row1)) (cdr C))))
      nil))

#+END_SRC

#+RESULTS:
: HAS-MULTIPLE-P

#+BEGIN_SRC lisp
(has-multiple-p '(#(1 2 3 4) #(1 1 1 1) #(2 4 6 8)))

#+END_SRC

#+BEGIN_SRC lisp :tangle "projector.lisp"
(defun redun-multiple (C)
  (if (has-multiple-p C)
      (redun-multiple (cdr C))
      (cons (car C) (redun-multiple (cdr C)))))
                                      

#+END_SRC

#+RESULTS:
: REDUN-MULTIPLE


** Project

#+BEGIN_SRC lisp :tangle "projector.lisp"
(defun project (C ne nv)
    (let ((Cprime (eliminate-equations C ne nv)))
         (redundancy-trim (coeff-reduction (eliminate-all Cprime nv)))))
#+END_SRC

#+RESULTS:
: PROJECT

#+BEGIN_SRC lisp 
(defun project-test (C ne nv)
    (let ((Cprime (eliminate-equations C ne nv)))
         (output-matrix (redundancy-trim (redun-trivial (eliminate-all Cprime nv))) 0 nv)))

#+END_SRC

#+RESULTS:
: PROJECT-TEST


#+BEGIN_SRC lisp :session :results output
  (let ((param '(1 2 2 2))
        (generator #'gen-at-least))
    (multiple-value-bind (C ne nv) (apply generator param)
      (project-test C ne nv)))
#+END_SRC

#+RESULTS:
#+begin_example
-3/2 <=-1/2x( 1)                                                               
-1/2 <=1/2x( 1)                                                               
  -1 <=-1/2x( 1)                                                               
   1 <=1/2x( 1)  +1x( 2)                                                      
   1 <=  +1x( 1)  +1x( 2)                                                      
   1 <=1/2x( 1)1/2x( 2)                                                      
   1 <=  +1x( 1)1/2x( 2)                                                      
   0 <=  +1x( 1)                                                               
   0 <=           +1x( 2)                                                      
-3/2 <=         -1/2x( 2)                                                      
-1/2 <=         1/2x( 2)                                                      
  -1 <=         -1/2x( 2)                                                      
#+end_example





#+COMMENT:
#+begin_example
  -1 <=                                                                        
   0 <=1/2x( 1)                                                               
   0 <=  +1x( 1)                                                               
-3/2 <=-1/2x( 1)                                                               
-1/2 <=                                                                        
-1/2 <=1/2x( 1)                                                               
  -2 <=  -1x( 1)                                                               
  -1 <=-1/2x( 1)                                                               
  -1 <=                                                                        
   0 <=           +1x( 2)                                                      
   1 <=1/2x( 1)  +1x( 2)                                                      
   1 <=  +1x( 1)  +1x( 2)                                                      
   0 <=         1/2x( 2)                                                      
   1 <=1/2x( 1)1/2x( 2)                                                      
   1 <=  +1x( 1)1/2x( 2)                                                      
  -1 <=                                                                        
   0 <=1/2x( 1)                                                               
   0 <=  +1x( 1)                                                               
  -1 <=                                                                        
   0 <=         1/2x( 2)                                                      
   0 <=           +1x( 2)                                                      
-3/2 <=         -1/2x( 2)                                                      
-1/2 <=                                                                        
-1/2 <=         1/2x( 2)                                                      
  -2 <=           -1x( 2)                                                      
  -1 <=         -1/2x( 2)                                                      
  -1 <=                                                                        
#+end_example


|    0 |  1/2 |    0 | 0 | 0 | 0 | 0 | 0 | 0 |
|    0 |    1 |    0 | 0 | 0 | 0 | 0 | 0 | 0 |
| -3/2 | -1/2 |    0 | 0 | 0 | 0 | 0 | 0 | 0 |
| -1/2 |  1/2 |    0 | 0 | 0 | 0 | 0 | 0 | 0 |
|   -2 |   -1 |    0 | 0 | 0 | 0 | 0 | 0 | 0 |
|   -1 | -1/2 |    0 | 0 | 0 | 0 | 0 | 0 | 0 |
|    0 |  1/2 |    0 | 0 | 0 | 0 | 0 | 0 | 0 |
|    0 |    1 |    0 | 0 | 0 | 0 | 0 | 0 | 0 |


|    0 |    0 |  1/2 | 0 | 0 | 0 | 0 | 0 | 0 |
|    1 |  1/2 |  1/2 | 0 | 0 | 0 | 0 | 0 | 0 |
|    1 |    1 |  1/2 | 0 | 0 | 0 | 0 | 0 | 0 |


|    0 |    0 |  1/2 | 0 | 0 | 0 | 0 | 0 | 0 |
| -3/2 |    0 | -1/2 | 0 | 0 | 0 | 0 | 0 | 0 |
| -1/2 |    0 |    0 | 0 | 0 | 0 | 0 | 0 | 0 |


-1 <= 0
0 <= 1/2 x1
0 <= x1
-3/2 <= -1/2 x1  ==> x1 <= 3
-1/2 <= 0
-1/2 <= 1/2 x1 ==> -1 <= x1
-2 <= x1
-1 <= -1/2 x1 ==> x1 <= 2  *******
-1 <= 0
0 <= 1/2 x2
1 <= 1/2 x1 + 1/2 x2  ==> 2 <= x1 + x2 ****
-1 <= 0
0 <= 1/2 x1
0 <= x1
-1 <= 0
0 <= 0
0 <= 1/2 x2
-3/2 <= -1/2 x2 ==> x2 <= 3
-1/2 <= 0

#+BEGIN_COMMENT
#### at_least_1(x_1,...,x_2) = 2  ; x_i in [0,..,2]
 1y(1,1) +2y(1,2)-x1 = 0
  y(1,0) + y(1,1) + y(1,2) = 1
 1y(2,1) +2y(2,2)-x2 = 0
  y(2,0) + y(2,1) + y(2,2) = 1
  y(1,2) + y(2,2) >= 1
y(1,0) >= 0
y(1,0) <= 1
y(1,1) >= 0
y(1,1) <= 1
y(1,2) >= 0
y(1,2) <= 1
y(2,0) >= 0
y(2,0) <= 1
y(2,1) >= 0
y(2,1) <= 1
y(2,2) >= 0
y(2,2) <= 1
#### After Projection
-1.00000 x1   -1.00000 x2   <= -2.00000 
+1.00000 x1                 <= 2.00000 
              +1.00000 x2   <= 2.00000 
#+END_COMMENT
